#########################################3
#File : execute.py
#Description : Takes the weight matrices generated from 
#train.py and executes each neural network with the test data.
#Also it generates a graph for the last neural network
#
#Author : Piyush Verma
############################################

import pickle
import math
from matplotlib import pyplot


#define global variables
trainingList = []
confusionMatrix = {}
weightMatrix = {}
costMatrix = {1:{1:0.2,2:-0.07,3:-0.07,4:-0.07},
              2:{1:-0.07,2:0.15,3:-0.07,4:-0.07}, 
              3:{1:-0.07,2:-0.07,3:0.05,4:-0.07}, 
              4:{1:-0.03,2:-0.03,3:-0.03,4:-0.03}}
output = []

#read training data from the csv file provided
def readTrainingData():
    global trainingList
    
    trainingList = []
    inputFile = open('train_data.csv')
    
    for line in inputFile:
        
        tempList = []
        
        linePointer = 0
        for i in range(0,2):
            commaLocation = line.find(",",linePointer,len(line))
            temp = line[linePointer:commaLocation]
            linePointer = commaLocation + 1
            tempList.append(float(temp))
            
        temp = line[commaLocation + 1:(len(line)-1)]
        tempList.append(temp)
        #print tempList
        trainingList.append(tempList)

#initialize the confuse matrix with all 0s
def initializeConfusionMatrix():
    for i in range(1,5):
        confusionMatrix[i] = {}
        for j in range(1,5):
            confusionMatrix[i][j] = 0
            

#calculate the values of the hidden nodes using input nodes and bias
def calculateHiddenNode(outputNode, index, inputBias):

    global trainingList
    sumOfWeights = 0    
    for i in range(0, 2):
        sumOfWeights = sumOfWeights + (trainingList[index][i]*weightMatrix[i][outputNode])
    sumOfWeights = sumOfWeights + weightMatrix[inputBias][outputNode]
    sigmoid = float(1/(1+math.exp((-1)*sumOfWeights)))
    return sigmoid

#calculate the values of the output notes using hidden nodes and hidden bias
def calculateOutputNode(outputNode, hiddenBias, hiddenMin, hiddenMax, hiddenValues):

    global trianingList
    sumOfWeights = 0    
    for hiddenNode in range(hiddenMin, hiddenMax+1):
        sumOfWeights = sumOfWeights + (hiddenValues[hiddenNode]*weightMatrix[hiddenNode][outputNode])
    
    #bias = 1   
    sumOfWeights = sumOfWeights + weightMatrix[hiddenBias][outputNode]   
    
    sigmoid = float(1/(1+math.exp((-1)*sumOfWeights)))
    return sigmoid

#Returns the index of the maximum value from all the output nodes
def calculateMaximumOutput(outputValues):
    maxValue = -1
    maxIndex = -1
    for node in outputValues:
        if(outputValues[node] > maxValue):
            maxValue = outputValues[node]
            maxIndex = node
            
    return maxIndex

#prints the confusion matrix
def printConfusionMatrix():
    global confusionMatrix
    print "Confusion Matrix for the provided Neural Network:"
    tempString = ""
    for i in range(1,5):
        for j in range(1,5):
            tempString = tempString + str(confusionMatrix[i][j]) + " "
        print tempString
        tempString=""
 
#calculates profit generated by the confusion matrix       
def calculateProfit():
    global costMatrix
    global confusionMatrix
    
    
    profit= 0
    for i in range(1,5):
        for j in range(1,5):
            profit = profit + (costMatrix[i][j]*confusionMatrix[i][j])
    print "Profit Obtained: "+str(profit)
    
#Calculates the actual against predicted outputs and updates the confusion matrix   
def calculateConfusionMatrix(hiddenMin, hiddenMax, outputMin, outputMax, inputBias, hiddenBias):
    global trainingList
    global confusionMatrix
    global output
    
    output = []
    
    initializeConfusionMatrix()
    
    for testData in range(0,74):
        
        #calculate the hidden layer values
        hiddenValues = {}
        for node in range(hiddenMin, hiddenMax+1):
            hidden = calculateHiddenNode(node, testData, inputBias)
            hiddenValues[node] = hidden
                
        #Calculate the output layer values
        outputValues = {}
        for node in range(outputMin, outputMax+1):#outputNodes:
            hidden = calculateOutputNode(node, hiddenBias, hiddenMin, hiddenMax, hiddenValues)
            outputValues[node] = hidden
        
        realOutput = int(trainingList[testData][2])
        maximumOutputNode = calculateMaximumOutput(outputValues)
        
        index = 1
        targetOutput = -1
        for i in range(outputMin, outputMax+1):
            if(maximumOutputNode == i):
                targetOutput = index
            index = index + 1
        confusionMatrix[realOutput][targetOutput] = confusionMatrix[realOutput][targetOutput] + 1
        
        output.append(targetOutput)
        
        
#plot the eccentricity vs six-folded rotational symmetry graph   
def plotGraph():
    global output
    global trainingList
    isBluePlotted = 0
    isRedPlotted = 0
    isGreenPlotted = 0
    isMagentaPlotted = 0
    for data in range(0,74):
        if(output[data] == 1):
            if(not isBluePlotted):
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'ro', label = 'Bolts')
                isBluePlotted = 1
            else:
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'ro')
        elif(output[data] == 2):
            if(not isRedPlotted):
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'md', label = 'Nuts')
                isRedPlotted = 1
            else:
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'md')
        elif(output[data] == 3):
            if(not isGreenPlotted):
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'bs', label = 'Rings')
                isGreenPlotted = 1
            else:
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'bs')
        elif(output[data] == 4):
            if(not isMagentaPlotted):
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'g^', label = 'Scrap')
                isMagentaPlotted = 1
            else:
                pyplot.plot(trainingList[data][0], trainingList[data][1], 'g^')
    
    pyplot.legend()     
    pyplot.xlabel("Six-fold Rotational Symmetry")
    pyplot.ylabel("Eccentricity")
    pyplot.show()


#calculates the number of errors and accuracy of the confusion matrix
def calculateErrorAndAccuracy():
    global confusionMatrix
    accuracy = 0
    
    for i in range(1,5):
        for j in range(1,5):
            if(i == j):
                accuracy = accuracy + confusionMatrix[i][j]
            
    accuracyPercentage = (float(accuracy)/(len(trainingList)))*100
    error = len(trainingList) - accuracy
    
    print "Accuracy: "+str(accuracyPercentage)
    print "Number of Errors : "+str(error)

def main():
    global weightMatrix
    readTrainingData();
    
    print 'Executing test data on neural network with 0 epochs...'
    file = open("weightMatrix1.txt", "r")
    weightMatrix = pickle.load(file)
    calculateConfusionMatrix(3, 7, 9, 12, 2, 8)
    printConfusionMatrix()
    calculateProfit()
    calculateErrorAndAccuracy()
    
    print 'Executing test data on neural network with 10 epochs...'
    file = open("weightMatrix2.txt", "r")
    weightMatrix = pickle.load(file)
    calculateConfusionMatrix(3, 7, 9, 12, 2, 8)
    printConfusionMatrix()
    calculateProfit()
    #plotGraph()
    calculateErrorAndAccuracy()
    
    print 'Executing test data on neural network with 100 epochs...'
    file = open("weightMatrix3.txt", "r")
    weightMatrix = pickle.load(file)
    calculateConfusionMatrix(3, 7, 9, 12, 2, 8)
    printConfusionMatrix()
    calculateProfit()
    #plotGraph()
    calculateErrorAndAccuracy()
    
    print 'Executing test data on neural network with 1000 epochs...'
    file = open("weightMatrix4.txt", "r")
    weightMatrix = pickle.load(file)
    calculateConfusionMatrix(3, 7, 9, 12, 2, 8)
    printConfusionMatrix()
    calculateProfit()
    #plotGraph()
    calculateErrorAndAccuracy()
    
    print 'Executing test data on neural network with 10000 epochs...'
    file = open("weightMatrix5.txt", "r")
    weightMatrix = pickle.load(file)
    calculateConfusionMatrix(3, 7, 9, 12, 2, 8)
    printConfusionMatrix()
    calculateProfit()
    plotGraph()
    calculateErrorAndAccuracy()

if (__name__ == '__main__'):
    main()